<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mapillary Split (Viewer + Map + FOV + Coverage Tiles)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS v4 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.VectorGrid (for vector tiles) -->
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100%; width: 100%; display: grid; grid-template-columns: 55% 45%; }
    #mly, #map { height: 100%; width: 100%; }
    #label {
      position: absolute; z-index: 9999; left: 10px; top: 10px;
      background: rgba(0,0,0,.6); color: #fff; padding: 6px 8px; border-radius: 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly"></div>
    <div id="map"></div>
  </div>
  <div id="label">bearing: —°</div>

  <script>
    // ==== Config ====
    const ACCESS_TOKEN = "MLY|24462366120070331|7b445698e786aaa212354b607653e542";
    const START_IMAGE_ID = "744575191439794";
    const FOV_DEGREES = 60;   // wedge aperture
    const RANGE_METERS = 60;  // wedge length

    // ==== Mapillary Viewer ====
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: ACCESS_TOKEN,
      imageId: START_IMAGE_ID,
    });

    // ==== Leaflet Map ====
    const map = L.map("map");
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    // ---- Coverage Vector Tiles ----
    const vtUrl =
      `https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}.pbf?access_token=${encodeURIComponent(ACCESS_TOKEN)}`;

    // Styling per coverage layer
    const vectorTileStyles = {
      // z 0–5 points
      overview: function(properties, zoom) {
        return {
          radius: 2.5,
          weight: 1,
          color: '#2b6cb0',
          fillColor: '#63b3ed',
          fill: true,
          fillOpacity: 0.9
        };
      },
      // z 6–14 sequences (lines)
      sequence: function(properties, zoom) {
        return {
          weight: 2,
          color: '#3182ce',
          opacity: 0.8
        };
      }
    };

    // Build layer
    const coverage = L.vectorGrid.protobuf(vtUrl, {
      vectorTileLayerStyles: vectorTileStyles,
      interactive: true,
      getFeatureId: f => f.properties.id // stable per feature for events
    }).addTo(map);

    // Click → move viewer
    coverage.on('click', e => {
      const p = e.layer && e.layer.properties ? e.layer.properties : {};
      // overview layer has 'id' (image id), sequence layer has 'image_id'
      const imageId = p.id || p.image_id;
      if (imageId) {
        viewer.moveTo(String(imageId));
      }
    });

    // ---- Current image marker + wedge ----
    let imageMarker = null;
    let wedge = null;
    let currentLatLng = null;
    let currentBearing = null;
    let firstPositioned = false;

    function destPoint(lat, lng, bearingDeg, distanceMeters) {
      const R = 6371000;
      const δ = distanceMeters / R;
      const θ = bearingDeg * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180;

      const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
      const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
      const sinθ = Math.sin(θ), cosθ = Math.cos(θ);

      const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * cosθ;
      const φ2 = Math.asin(sinφ2);
      const y = sinθ * sinδ * cosφ1;
      const x = cosδ - sinφ1 * sinφ2;
      const λ2 = λ1 + Math.atan2(y, x);

      return [ (φ2 * 180/Math.PI), ((λ2 * 180/Math.PI + 540) % 360) - 180 ];
    }

    function updateWedge() {
      if (!currentLatLng || currentBearing == null) return;

      const half = FOV_DEGREES / 2;
      const start = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing - half, RANGE_METERS);
      const end   = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing + half, RANGE_METERS);

      const coords = [
        [currentLatLng.lat, currentLatLng.lng],
        [start[0], start[1]],
        [end[0], end[1]]
      ];

      if (!wedge) {
        wedge = L.polygon(coords, { weight: 1, fillOpacity: 0.15 });
        wedge.addTo(map);
      } else {
        wedge.setLatLngs(coords);
      }
    }

    function updateMarker(lat, lng) {
      const ll = [lat, lng];
      if (!imageMarker) {
        imageMarker = L.circleMarker(ll, { radius: 6, weight: 2, fillOpacity: 1 });
        imageMarker.addTo(map);
      } else {
        imageMarker.setLatLng(ll);
      }
    }

    const label = document.getElementById('label');

    // Drive map from image events
    viewer.on('image', (ev) => {
      const img = ev.image;
      if (!img || !img.lngLat) return;

      currentLatLng = { lat: img.lngLat.lat, lng: img.lngLat.lng };
      if (typeof img.compassAngle === 'number') currentBearing = img.compassAngle;

      updateMarker(currentLatLng.lat, currentLatLng.lng);
      updateWedge();

      if (!firstPositioned) {
        firstPositioned = true;
        map.setView([currentLatLng.lat, currentLatLng.lng], 18);
        setTimeout(() => map.invalidateSize(), 0);
      }

      if (typeof currentBearing === 'number') {
        label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      }
    });

    // Keep wedge rotating with camera
    viewer.on('bearing', (e) => {
      if (typeof e.bearing !== 'number') return;
      currentBearing = e.bearing;
      label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      updateWedge();
    });
  </script>
</body>
</html>
