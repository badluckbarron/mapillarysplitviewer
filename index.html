<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mapillary Split (Viewer + Map + FOV + Graph API filtered)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100%; width: 100%; display: grid; grid-template-columns: 55% 45%; }
    #mly, #map { height: 100%; width: 100%; }
    #label {
      position: absolute; z-index: 9999; left: 10px; top: 10px;
      background: rgba(0,0,0,.6); color: #fff; padding: 6px 8px; border-radius: 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .legend {
      position: absolute; right: 10px; bottom: 10px; z-index: 9999;
      background: rgba(255,255,255,.95); border: 1px solid #ccc; border-radius: 6px;
      padding: 6px 8px; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly"></div>
    <div id="map"></div>
  </div>
  <div id="label">bearing: —°</div>
  <div class="legend">showing images by user_id <b>461128976844139</b> nearest the map center</div>

  <script>
    // ==== Config ====
    const ACCESS_TOKEN = "MLY|24462366120070331|7b445698e786aaa212354b607653e542";
    const START_IMAGE_ID = "744575191439794";
    const FILTER_USER_ID = "461128976844139";

    // FOV wedge + fetch behavior
    const FOV_DEGREES = 60;               // wedge aperture
    const RANGE_METERS = 60;              // wedge length
    const PAN_THRESHOLD_M = 152.4;        // 500 ft before refetch on pan
    const IMAGE_LIMIT = 1000;             // Graph API page size
    const REFRESH_DEBOUNCE_MS = 250;      // debounce for map interactions
    const NEAR_LIMIT = 400;               // draw at most this many nearest points

    // Zoom-aware "near" radius (meters) to focus points around center
    function nearRadiusForZoom(z) {
      if (z >= 18) return 150;
      if (z >= 17) return 250;
      if (z >= 16) return 400;
      if (z >= 15) return 700;
      if (z >= 14) return 1200;
      return 2000;
    }

    // ==== Mapillary Viewer ====
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: ACCESS_TOKEN,
      imageId: START_IMAGE_ID,
    });

    // ==== Leaflet Map ====
    const map = L.map("map");
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    // Layers & state
    const imagesLayer = L.layerGroup().addTo(map);
    let imageMarker = null;
    let wedge = null;
    let currentLatLng = null;
    let currentBearing = null;
    let firstPositioned = false;

    // --- Utils ---
    function haversine(a, b) {
      const R = 6371000;
      const φ1 = a.lat * Math.PI/180, φ2 = b.lat * Math.PI/180;
      const dφ = (b.lat - a.lat) * Math.PI/180;
      const dλ = (b.lng - a.lng) * Math.PI/180;
      const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
      return 2*R*Math.asin(Math.sqrt(s));
    }

    function getViewportBBox() {
      const b = map.getBounds();
      return { minLon: b.getWest(), minLat: b.getSouth(), maxLon: b.getEast(), maxLat: b.getNorth() };
    }

    function destPoint(lat, lng, bearingDeg, distanceMeters) {
      const R = 6371000;
      const δ = distanceMeters / R;
      const θ = bearingDeg * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180;

      const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
      const sinδ = Math.sin(δ),  cosδ = Math.cos(δ);
      const sinθ = Math.sin(θ),  cosθ = Math.cos(θ);

      const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * cosθ;
      const φ2 = Math.asin(sinφ2);
      const y = sinθ * sinδ * cosφ1;
      const x = cosδ - sinφ1 * sinφ2;
      const λ2 = λ1 + Math.atan2(y, x);

      return [ (φ2 * 180/Math.PI), ((λ2 * 180/Math.PI + 540) % 360) - 180 ];
    }

    function updateWedge() {
      if (!currentLatLng || currentBearing == null) return;
      const half = FOV_DEGREES / 2;
      const start = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing - half, RANGE_METERS);
      const end   = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing + half, RANGE_METERS);
      const coords = [
        [currentLatLng.lat, currentLatLng.lng],
        [start[0], start[1]],
        [end[0], end[1]]
      ];
      if (!wedge) {
        wedge = L.polygon(coords, { weight: 1, fillOpacity: 0.15 });
        wedge.addTo(map);
      } else {
        wedge.setLatLngs(coords);
      }
    }

    function updateMarker(lat, lng) {
      const ll = [lat, lng];
      if (!imageMarker) {
        imageMarker = L.circleMarker(ll, { radius: 6, weight: 2, fillOpacity: 1 });
        imageMarker.addTo(map);
      } else {
        imageMarker.setLatLng(ll);
      }
    }

    // --- Graph API fetch (client-side filter on creator_id) ---
    async function fetchImagesForViewport(bbox) {
      const url = new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields", "id,computed_geometry,creator_id");
      url.searchParams.set("limit", String(IMAGE_LIMIT));
      url.searchParams.set("bbox", `${bbox.minLon},${bbox.minLat},${bbox.maxLon},${bbox.maxLat}`);
      url.searchParams.set("access_token", ACCESS_TOKEN);

      try {
        const resp = await fetch(url.toString());
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        return Array.isArray(data.data) ? data.data : [];
      } catch (e) {
        return [];
      }
    }

    function drawNearestFiltered(items) {
      imagesLayer.clearLayers();

      const center = map.getCenter();
      const nearRadius = nearRadiusForZoom(map.getZoom());

      // 1) Filter to the requested user_id (creator_id).
      const mine = items.filter(d => String(d.creator_id) === String(FILTER_USER_ID) && d.computed_geometry && d.computed_geometry.type === "Point");

      // 2) Compute distance to map center for each, sort by distance.
      const enriched = mine.map(d => {
        const [lon, lat] = d.computed_geometry.coordinates;
        const dist = haversine(center, { lat, lng: lon });
        return { d, lat, lon, dist };
      }).sort((a, b) => a.dist - b.dist);

      // 3) Prefer those within the zoom-aware radius; if none, take the nearest anyway.
      const within = enriched.filter(x => x.dist <= nearRadius);
      const chosen = (within.length ? within : enriched).slice(0, NEAR_LIMIT);

      // 4) Draw points
      chosen.forEach(({ d, lat, lon }) => {
        const m = L.circleMarker([lat, lon], { radius: 3.5, weight: 1, fillOpacity: 0.85 });
        m.on("click", () => viewer.moveTo(String(d.id)));
        m.addTo(imagesLayer);
      });
    }

    // --- Refetch logic on interactions ---
    let lastPanChecked = null;
    let debounceTimer = null;

    async function refetchViewport(force=false) {
      const center = map.getCenter();
      if (!force && lastPanChecked) {
        const dist = haversine(lastPanChecked, { lat: center.lat, lng: center.lng });
        if (dist < PAN_THRESHOLD_M) return;
      }
      lastPanChecked = { lat: center.lat, lng: center.lng };

      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        const bbox = getViewportBBox();
        const items = await fetchImagesForViewport(bbox);
        drawNearestFiltered(items);
      }, REFRESH_DEBOUNCE_MS);
    }

    // Drive from viewer
    const label = document.getElementById('label');

    viewer.on('image', (ev) => {
      const img = ev.image;
      if (!img || !img.lngLat) return;

      currentLatLng = { lat: img.lngLat.lat, lng: img.lngLat.lng };
      if (typeof img.compassAngle === 'number') currentBearing = img.compassAngle;

      updateMarker(currentLatLng.lat, currentLatLng.lng);
      updateWedge();

      if (!firstPositioned) {
        firstPositioned = true;
        map.setView([currentLatLng.lat, currentLatLng.lng], 18);
        setTimeout(() => map.invalidateSize(), 0);
        refetchViewport(true);  // initial fetch
      } else {
        refetchViewport(false); // on image changes during navigation
      }

      if (typeof currentBearing === 'number') {
        label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      }
    });

    viewer.on('bearing', (e) => {
      if (typeof e.bearing !== 'number') return;
      currentBearing = e.bearing;
      label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      updateWedge();
    });

    // Map interaction triggers
    map.on('zoomend', () => refetchViewport(true));     // any zoom => refetch
    map.on('moveend', () => refetchViewport(false));    // pan > threshold => refetch
  </script>
</body>
</html>
