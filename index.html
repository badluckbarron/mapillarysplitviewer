<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mapillary Split (Viewer + Map + FOV + Graph API filtered by user)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100%; width: 100%; display: grid; grid-template-columns: 55% 45%; }
    #mly, #map { height: 100%; width: 100%; }
    #label {
      position: absolute; z-index: 9999; left: 10px; top: 10px;
      background: rgba(0,0,0,.6); color: #fff; padding: 6px 8px; border-radius: 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .legend {
      position: absolute; right: 10px; bottom: 10px; z-index: 9999;
      background: rgba(255,255,255,.9); border: 1px solid #ccc; border-radius: 6px;
      padding: 6px 8px; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly"></div>
    <div id="map"></div>
  </div>
  <div id="label">bearing: —°</div>
  <div class="legend">filtered user_id: <b>461128976844139</b></div>

  <script>
    // ==== Config ====
    const ACCESS_TOKEN = "MLY|24462366120070331|7b445698e786aaa212354b607653e542";
    const START_IMAGE_ID = "744575191439794";
    const FILTER_USER_ID = "461128976844139";

    const FOV_DEGREES = 60;          // wedge aperture
    const RANGE_METERS = 60;         // wedge length
    const PAN_THRESHOLD_M = 152.4;   // 500 ft
    const IMAGE_LIMIT = 1000;        // max images per request (Graph API cap is typically 1000)
    const REFRESH_DEBOUNCE_MS = 250;

    // ==== Mapillary Viewer ====
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: ACCESS_TOKEN,
      imageId: START_IMAGE_ID,
    });

    // ==== Leaflet Map ====
    const map = L.map("map");
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    // Layers
    const imagesLayer = L.layerGroup().addTo(map);
    let imageMarker = null;
    let wedge = null;

    // State
    let currentLatLng = null;
    let currentBearing = null;
    let firstPositioned = false;

    // Utils
    function haversine(a, b) {
      const R = 6371000;
      const φ1 = a.lat * Math.PI/180, φ2 = b.lat * Math.PI/180;
      const dφ = (b.lat - a.lat) * Math.PI/180;
      const dλ = (b.lng - a.lng) * Math.PI/180;
      const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
      return 2*R*Math.asin(Math.sqrt(s));
    }

    function getViewportBBox() {
      const b = map.getBounds();
      return {
        minLon: b.getWest(),
        minLat: b.getSouth(),
        maxLon: b.getEast(),
        maxLat: b.getNorth()
      };
    }

    function destPoint(lat, lng, bearingDeg, distanceMeters) {
      const R = 6371000;
      const δ = distanceMeters / R;
      const θ = bearingDeg * Math.PI / 180;
      const φ1 = lat * Math.PI / 180, λ1 = lng * Math.PI / 180;

      const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
      const sinδ = Math.sin(δ),  cosδ = Math.cos(δ);
      const sinθ = Math.sin(θ),  cosθ = Math.cos(θ);

      const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * cosθ;
      const φ2 = Math.asin(sinφ2);
      const y = sinθ * sinδ * cosφ1;
      const x = cosδ - sinφ1 * sinφ2;
      const λ2 = λ1 + Math.atan2(y, x);

      return [ (φ2 * 180/Math.PI), ((λ2 * 180/Math.PI + 540) % 360) - 180 ];
    }

    function updateWedge() {
      if (!currentLatLng || currentBearing == null) return;
      const half = FOV_DEGREES / 2;
      const start = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing - half, RANGE_METERS);
      const end   = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing + half, RANGE_METERS);
      const coords = [
        [currentLatLng.lat, currentLatLng.lng],
        [start[0], start[1]],
        [end[0], end[1]]
      ];
      if (!wedge) {
        wedge = L.polygon(coords, { weight: 1, fillOpacity: 0.15 });
        wedge.addTo(map);
      } else {
        wedge.setLatLngs(coords);
      }
    }

    function updateMarker(lat, lng) {
      const ll = [lat, lng];
      if (!imageMarker) {
        imageMarker = L.circleMarker(ll, { radius: 6, weight: 2, fillOpacity: 1 });
        imageMarker.addTo(map);
      } else {
        imageMarker.setLatLng(ll);
      }
    }

    // --- Graph API fetch limited to a user ---
    // Some deployments accept `user_ids=...`. If that fails, we fall back to client-side filter using `creator_id`.
    async function fetchImagesForViewportFilteredByUser(bbox) {
      const base = new URL("https://graph.mapillary.com/images");
      base.searchParams.set("fields", "id,computed_geometry,creator_id");
      base.searchParams.set("limit", String(IMAGE_LIMIT));
      base.searchParams.set("bbox", `${bbox.minLon},${bbox.minLat},${bbox.maxLon},${bbox.maxLat}`);
      base.searchParams.set("access_token", ACCESS_TOKEN);

      // Attempt server-side filter first
      let urlWithUser = new URL(base);
      urlWithUser.searchParams.set("user_ids", FILTER_USER_ID);

      try {
        let resp = await fetch(urlWithUser.toString());
        // If the param isn't supported, some servers return 400/500. Fall back below.
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        // If we got data, we're done.
        if (Array.isArray(data.data)) return data.data;
        // If structure unexpected, fall through to fallback.
      } catch (e) {
        // Fallback: fetch without user filter and filter on client by creator_id
        try {
          const resp2 = await fetch(base.toString());
          if (!resp2.ok) throw new Error(`HTTP ${resp2.status}`);
          const data2 = await resp2.json();
          const items = Array.isArray(data2.data) ? data2.data : [];
          return items.filter(d => String(d.creator_id) === FILTER_USER_ID);
        } catch (e2) {
          // On failure, return empty
          return [];
        }
      }

      return [];
    }

    // --- Drawing points ---
    function drawImagePoints(items) {
      imagesLayer.clearLayers();
      items.forEach(d => {
        const g = d.computed_geometry;
        if (!g || g.type !== "Point" || !Array.isArray(g.coordinates)) return;
        const [lon, lat] = g.coordinates;
        const m = L.circleMarker([lat, lon], { radius: 3.5, weight: 1, fillOpacity: 0.85 });
        m.on("click", () => viewer.moveTo(String(d.id)));
        m.addTo(imagesLayer);
      });
    }

    // --- Refetch logic on interactions ---
    let lastPanChecked = null;
    let debounceTimer = null;

    function scheduleViewportFetch(force=false) {
      const center = map.getCenter();
      if (!force && lastPanChecked) {
        const dist = haversine(lastPanChecked, { lat: center.lat, lng: center.lng });
        if (dist < PAN_THRESHOLD_M) return;
      }
      lastPanChecked = { lat: center.lat, lng: center.lng };

      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(async () => {
        const bbox = getViewportBBox();
        const items = await fetchImagesForViewportFilteredByUser(bbox);
        drawImagePoints(items);
      }, REFRESH_DEBOUNCE_MS);
    }

    // Drive from viewer
    const label = document.getElementById('label');

    viewer.on('image', (ev) => {
      const img = ev.image;
      if (!img || !img.lngLat) return;

      currentLatLng = { lat: img.lngLat.lat, lng: img.lngLat.lng };
      if (typeof img.compassAngle === 'number') currentBearing = img.compassAngle;

      updateMarker(currentLatLng.lat, currentLatLng.lng);
      updateWedge();

      if (!firstPositioned) {
        firstPositioned = true;
        map.setView([currentLatLng.lat, currentLatLng.lng], 18);
        setTimeout(() => map.invalidateSize(), 0);
        // initial fetch for the current viewport
        scheduleViewportFetch(true);
      } else {
        // center moved because image changed? refresh around viewer when it pans a lot
        scheduleViewportFetch(false);
      }

      if (typeof currentBearing === 'number') {
        label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      }
    });

    viewer.on('bearing', (e) => {
      if (typeof e.bearing !== 'number') return;
      currentBearing = e.bearing;
      label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      updateWedge();
    });

    // Map interaction triggers
    map.on('zoomend', () => scheduleViewportFetch(true));     // any zoom => refetch
    map.on('moveend', () => scheduleViewportFetch(false));    // pan > 500ft => refetch
  </script>
</body>
</html>
