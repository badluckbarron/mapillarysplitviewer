<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mapillary Split View (Viewer + Map with FOV)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS v4 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /* Make it fill the widget */
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100%; width: 100%; display: grid; grid-template-columns: 1fr 1fr; }
    #mly, #map { height: 100%; width: 100%; }
    /* Small status label (optional) */
    #label {
      position: absolute; z-index: 9999; left: 10px; top: 10px;
      background: rgba(0,0,0,.6); color: #fff; padding: 6px 8px; border-radius: 6px;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="mly"></div>
    <div id="map"></div>
  </div>
  <div id="label">bearing: —°</div>

  <script>
    // ==== Config ====
    const ACCESS_TOKEN = "MLY|24462366120070331|7b445698e786aaa212354b607653e542";
    const START_IMAGE_ID = "744575191439794";
    const FOV_DEGREES = 60;     // approximate field-of-view for wedge (tweak if you prefer)
    const RANGE_METERS = 60;    // wedge length (meters) from camera position

    // ==== Mapillary Viewer ====
    const viewer = new mapillary.Viewer({
      container: "mly",
      accessToken: ACCESS_TOKEN,
      imageId: START_IMAGE_ID,
    });

    // ==== Leaflet Map ====
    const map = L.map("map");
    const basemap = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      { attribution: "&copy; OpenStreetMap" }
    ).addTo(map);

    // Marker and wedge layers
    let imageMarker = null;
    let wedge = null;
    let currentLatLng = null;
    let currentBearing = null;
    let firstPositioned = false;

    // Haversine-based destination point (bearing degrees, distance meters)
    function destPoint(lat, lng, bearingDeg, distanceMeters) {
      const R = 6371000; // meters
      const δ = distanceMeters / R;
      const θ = bearingDeg * Math.PI / 180;

      const φ1 = lat * Math.PI / 180;
      const λ1 = lng * Math.PI / 180;

      const sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1);
      const sinδ = Math.sin(δ), cosδ = Math.cos(δ);
      const sinθ = Math.sin(θ), cosθ = Math.cos(θ);

      const sinφ2 = sinφ1 * cosδ + cosφ1 * sinδ * cosθ;
      const φ2 = Math.asin(sinφ2);
      const y = sinθ * sinδ * cosφ1;
      const x = cosδ - sinφ1 * sinφ2;
      const λ2 = λ1 + Math.atan2(y, x);

      return [ (φ2 * 180/Math.PI), ((λ2 * 180/Math.PI + 540) % 360) - 180 ];
    }

    function updateWedge() {
      if (!currentLatLng || currentBearing == null) return;

      const half = FOV_DEGREES / 2;
      const start = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing - half, RANGE_METERS);
      const end   = destPoint(currentLatLng.lat, currentLatLng.lng, currentBearing + half, RANGE_METERS);

      const coords = [
        [currentLatLng.lat, currentLatLng.lng],
        [start[0], start[1]],
        [end[0], end[1]]
      ];

      if (!wedge) {
        wedge = L.polygon(coords, {
          weight: 1, fillOpacity: 0.15
        }).addTo(map);
      } else {
        wedge.setLatLngs(coords);
      }
    }

    function updateMarker(lat, lng) {
      const ll = [lat, lng];
      if (!imageMarker) {
        imageMarker = L.circleMarker(ll, { radius: 6, weight: 2, fillOpacity: 1 });
        imageMarker.addTo(map);
      } else {
        imageMarker.setLatLng(ll);
      }
    }

    // 1) Sync position (fires when current image position changes)
    viewer.on('position', async () => {
      const pos = await viewer.getPosition(); // { imageId, lngLat: { lng, lat } }
      currentLatLng = { lat: pos.lngLat.lat, lng: pos.lngLat.lng };

      updateMarker(currentLatLng.lat, currentLatLng.lng);
      updateWedge();

      if (!firstPositioned) {
        firstPositioned = true;
        map.setView([currentLatLng.lat, currentLatLng.lng], 18);
      }
    });

    // 2) Sync bearing (fires when camera direction changes)
    const label = document.getElementById('label');
    viewer.on('bearing', (ev) => {
      currentBearing = ev.bearing; // degrees clockwise from north
      label.textContent = `bearing: ${currentBearing.toFixed(1)}°`;
      updateWedge();
    });

    // 3) Also update on explicit image change (optional redundancy)
    viewer.on('image', async (ev) => {
      // You could read ev.image.compassAngle or ev.image.lngLat here if desired.
      // We'll rely on the position/bearing events above to keep things in sync.
    });
  </script>
</body>
</html>
